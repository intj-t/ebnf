<<*>>=
global pixsemantics

procedure writegrammar(outfile, g, yacc)
  ps := pixsemantics
  write(outfile, "%start ", g.start)
  if \yacc then { yacctx(g) ; pixsemantics := set(["{"]) }
  if /yacc then
    every t := key(g.terms) do
      write(outfile, "%term ", t, " " || (t ~== g.terms[t]) | "")
  else
    every write(outfile, "%token ", (!sort(g.terms, 2))[2])
  <<write out precedence info from [[g]]>>
  write(outfile, "%%")
  every writes(outfile, lhs := !g.ntlist, " : ") do
    case type(rhs := g.nonterms[lhs]) of {
      "Opt" | "Clo" | "Cat" | "string" : 
              { writes(outfile, nodepix(g, rhs)); write(outfile, ";") }
      "Alt" : { write(outfile, nodepix(g, rhs, s := "\n " || repl(" ", *lhs)))
                write(outfile, s[2:0], ";") }
      default : error("impossible node type")
    }
  pixsemantics := ps
  return g
end
<<write out precedence info from [[g]]>>=
maxprec := 0
every maxprec <:= !g.prec
l := []
every i := 1 to maxprec do put(l, [])
al := list(maxprec)
every k := key(g.prec) do {
  put(l[g.prec[k]], k)
  al[g.prec[k]] := g.assoc[k]
}
every i := 1 to maxprec do {
  writes(outfile, "%", al[i])
  every writes(outfile, " ", g.terms[!l[i]])
  write(outfile)
}
<<*>>=
procedure nodepix(g, node, separator)
  return case type(node) of {
    "Opt" : "[" || nodepix(g, node.node) || "]"
    "Clo" : "{" || nodepix(g, node.node) || "}"
    "Cat" : {
       s := ""
       every s ||:= nodepix(g, !node.list, node) || " "
       <<add precedence from [[node]] to [[s]] if needed>>
       if \node.semantics & /pixsemantics then # frightful cheat
         s || "/* " || commaseparate(node.semantics, "\n") || " */"
       else 
         s[1:-1] | ""
     }
    "Alt" : {
       s := ""
       sep := if type(separator) == "string" then separator else " "
       every s ||:= sep || "| " || nodepix(g, !node.list)
       s := s[*sep+3:0]
       if type(separator) == "Cat" then "(" || s || ")" else s
     }
    "string" : \g.terms[node] | node
    default  : error("impossible node type")
  }
end
@
<<add precedence from [[node]] to [[s]] if needed>>=
if not (if member(g.terms, lp := node.list[*node.list to 1 by -1]) then
          lp == \node.precterm) then
  s ||:= "%prec " || g.terms[\node.precterm] || " "
<<*>>=
procedure yacctx(g)
  static quote, n
  initial {quote := "\""; n := create("XXX" || seq())}
  every k := key(g.terms) do
    if g.terms[k][1] == g.terms[k][-1] == quote then 
      if *g.terms[k] = 3 then g.terms[k][1] := g.terms[k][-1] := "'"
      else g.terms[k] := 
        (g.terms[k] ? {
          move(1)
          map(tab(many(&letters)), &lcase, &ucase) | @n
        })
  return g
end

          