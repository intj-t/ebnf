<<*>>=
link openfile

procedure main(args)
  opts := []
  emitter := Icon
  while case args[1] of {
    "-d"       : put(opts, args[1])
    "-flatten" : flatten := args[1]
    "-slr"     : dolr := slr1
    "-lr1"     : lr1 := args[1]
    "-parser"  : doparser  := args[1]
    "-grammar" : dogrammar := args[1]
    "-prec"    : showprec := args[1]
    "-icn" : emitter := Icon
    "-c"   : emitter := C
    "-yacc" : yacc := args[1]
    default : if args[1][1] == "-" then stop("Unrecognized argument ", args[1])
  } do get(args)
  if /showprec & /doparser & /dogrammar & /dolr then doparser := 1
  case *args of {
    0       : g := readgrammar(&input)
    1       : g := readgrammar(open(filename := args[1])) | 
                               write(&errout, "Can't open ", filename)
    default : usage()
  }
  emitter("stringdef")(g)
  if \flatten then
    flattengrammar(g)
  if \lr1 | \dolr then
    lrxform(g)
  writegrammar(\dogrammar & &output, g, yacc)
  if \doparser then {
    emitter("infersemantics")(g)
    ll1(g, opts ||| args, emitter("emit"))
  }
  if \dolr then {
    emitter("infersemantics")(g)
    dolr(g, opts ||| args, emitter("lr"))
  }
  if \showprec then
    emitter("precedence")(g)
end

procedure usage()
  every write("Usage: ebnf [options] [grammarfile]" |
"Options:" | 
"-flatten  flatten grammar -- needed if LL(1) uses semantic actions" |
"-lalr     emit SLR(1) parser (Icon only)" |
"-lr1      remove EBNF constructs & make LR(1) grammar" |
"-parser   spit an LL(1) recursive descent parser on stdout (default)" |
"-grammar  rewrite the grammar on stdout (after flattening or yaccifying" |
"-yacc     if emitting grammar, put it in yacc form" |
"-icn      emit Icon (the default)" |
"-c        emit a C parser" |
"" |
"Useful combinations:" |
"  New grammars w/o extended BNF:" |
"    -flatten -grammar" |
"    -lr1 -grammar" |
"  Parsers:" |
"    -lalr" |
"    -flatten -parser"
)
  stop()
end
