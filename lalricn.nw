<<*>>=
record caserec(tab, val, def)

procedure newcase(val)
  return caserec(table(), val)
end

procedure addbranch(cr, value, L[])
  s := ""; every s ||:= string(!L)
  if value == "default" then
    /cr.def := s | impossible("duplicate defaults in constructed case")
  else {
    /cr.tab[s] := []
    put(cr.tab[s], value)
  }
  return t
end

procedure casestring(cr)
  local def
  if /cr.def & *cr.tab = 1 then
    return key(cr.tab)
  else {
    s := "case " || cr.val || " of {"
    every p := !sort(cr.tab) do
      s ||:= "\n  " || commaseparate(p[2], " | ") || " : " || p[1]
    s ||:= "\n  default : " || \cr.def
    s ||:= "\n}"
    return s
  }
end

procedure writecase(cr)
  local def
  if /cr.def & *cr.tab = 1 then
    write(key(cr.tab))
  else {
    write("case ", cr.val, " of {")
    every p := !sort(cr.tab) do
      write(commaseparate(p[2], " | "), " : ", p[1])
    write("  default : ", \cr.def)
    write("}")
  }
end
@
<<*>>=  
procedure IconLalr(g)
  reductions := set()
  tick := 1 + *itemsetlist / 50
  lasttick := 0; writes(&errout, "Action table...")
  <<write parser>>
  write(&errout, " done")
  <<write definition of [[shift]]>>
  lasttick := 0; writes(&errout, "Goto table...")
  <<write definition of [[reduce]]>>
  write(&errout, " done")
  if \IconReserved then {IconEmitReserved(); IconReserved := &null}
  return
end
@
<<write parser>>=
iwrite(0, "procedure P_", g.start, "(states, values)")
iwrite(2, "/states := [1]; /values := []")
statecase := newcase("states[1]")
every i := 1 to *itemsetlist do {
  <<tick on [[i]]>>
  tokencase := newcase("token")
  every tok := 0 ~=== key(ac := actions(g, itemsetlist[i])) do {
    addbranch(tokencase, tok, 
    case ac[tok][2] of {
      "shift"  : concat("shift(states, values, ", itemsetnos[ac[tok][3]], ")")
      "reduce" : { insert(reductions, ac[tok][3].uniqueid)
                  concat("reduce(states, values, ", ac[tok][3].uniqueid, ") # ",
	    itemimage(ac[tok][3]))
                 }
      "error"  : "error(\"syntax error\")"
      "accept" : "return values[1]"
      default  : impossible("action type ", ac[tok][2])
    })
  }
  if member(ac, 0) then 
    addbranch(tokencase, "default", "error(\"syntax error\")")
  addbranch(statecase, i, casestring(tokencase))
}
iwrites(2, "repeat ")
writecase(statecase)
iwrite(0, "end")
@
<<tick on [[i]]>>=
while lasttick < i do {
  writes(&errout, ".")
  lasttick +:= tick
}
<<*>>=
procedure concat(L[])
  s := ""
  every x := !L do s ||:= (string|image)(x)
  return s
end
@
<<write definition of [[reduce]]>>=
write("procedure reduce(states, values, itemno)")
write("  rdebug(\\iidebug, itemno)")
itemnocase := newcase("itemno")
sr := sort(reductions) ; tick := 1 + sr[-1] / 50
every it := itemtab[i := !sr] do {
  <<tick on [[i]]>>
  if not it.dotpos = *it.list + 1 then impossible("bad reduction")
  L := [itemnocase, i, "{"]
  case *it.list of {
    0 : &null
    1 : put(L, "ii1 := pop(values) ; pop(states)\n")
    default : 
      every put(L, concat("ii", i := *it.list to 1 by -1, 
                          " := pop(values) ; pop(states)\n"))
  }
  if \it.semantics then
    every put(L, "push(values, {\n" | !it.semantics || "\n" | "} | &null)\n")
  else 
    put(L, "push(values, &null)\n")
  if *statecase.tab > 1 then 
    addbranch(statecase, "default", 
              "stop(\"impossible state \", states[1], \"in reduce\")")
  statecase := newcase("states[1]")
  every t := itemsetnos[\goto[s := key(goto)][it.nt]] do
    addbranch(statecase, itemsetnos[s], t)
  every put(L, "push(states, " | casestring(statecase) | ")\n")
  put(L, "}")
  addbranch ! L
}
addbranch(itemnocase, "default", "stop(\"impossible reduction \", itemno)")
writecase(itemnocase)
write("end")
<<write [[rdebug]]>>
@
<<write definition of [[shift]]>>=
  every write(
"" |
"link ebnflex" |
"" |
"procedure shift(states, values, stateno)" |
"  write(\\iidebug, \"Shifted \", token, \" [\", tval, \"]\")" |
"  push(values, tval)" | 
"  push(states, stateno)" |
"  lex()" |
"  return" |
"end")
<<write [[rdebug]]>>=
every write(
"procedure rdebug(outfile, itemno)" |
"  static tab" |
"  initial {" |
"    tab := table()")
every it := itemtab[i := !sort(reductions)] do
  write("    tab[", i, "] := ", image(it.nt || " -> " || 
                                      commaseparate(it.list, " ") || " (" || i || ")"))
every write(
"  }" |
"  return write(outfile, \\tab[itemno] | itemno || \"???\")" |
"end" |
"")
